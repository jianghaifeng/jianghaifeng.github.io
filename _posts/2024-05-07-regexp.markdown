---
layout: post
title:  "regexp"
date:   2024-05-07 18:29:14 +0800
categories: tech learning
---

### character class 字符组  

1. 由一对方括号和方括号内的字符组成，匹配的字符位置为字符组中任意一个字符  
例如 `/[abcde]/` 会匹配到 this is <font color=red>a</font>n example   
字符组内字符的摆放顺序是任意的，也可以允许重复  
字符组后面添加其他字符，会依次匹配  
例如 `/[abcde]mp/` 会匹配到 this is an ex<font color=red>amp</font>le 

1. 范围表示法  
例如，要匹配 this is the 1st example 中的数字，可以用 /[0123456789]/ 去匹配
如果要匹配任意一个小写字母，需要把26个字母全部写一遍就比较麻烦，这里，有一种简单的范围表示法，使用连字符把要匹配的字符连起来，左右分别表示开始和结束的字符，例如  
`/[0-9]/` 和 `/[a-z]/` 分别表示匹配任意的数字和小写字母  
每一个独立的范围表示法都对应着一串特定字符，它们也可以连起来使用，例如 `/[a-zA-Z]/` 就可以匹配所有大小写字符  
那如果我们要匹配减号呢，我们可以把连字符放到字符组的最前面或者最后面，例如 `/[0-9-]/` 或者 `/[-0-9]/` 均可以匹配到 the substract operator is <font color=red>-</font> and the add operator is +  
还有一种方式就是转义，例如 `/[0\-9]/`  

1. 简记法  
正则表达式还为那些经常使用的匹配字符集合提供了相应的简记法，比如数字 `[0-9]` 可以表示为 `/\d/`  
在PCRE中，简记一共有6种，分别为：  
digit: `\d` 表示数字，等同于 `[0-9]`  
word: `\w` 表示任意的数字，字母，下划线，等同于`[0-9a-zA-Z_`  
space: `\s` 表示任意空格字符，等同于`[\t\r\n\v\f]`  
他们也用相应的补集形式：  
`\D` 表示非数字  
`\W` 表示非字符  
`\S` 表示非空白  

1. 排除型字符组  
字符组以`^`符号开头，表示将没有在当前字符组中的字符作为匹配字符，例如`/[^0-9]/`就和`\D`表示相同的含义

### Quantifier 量词  
1. 量词规定了正则中某个子模式的匹配次数，例如我们知道一个字符组仅能匹配文本中的一个字符，例如 `/[is]/` 能匹配 Th<font color=red>i</font>s is the first example  
我们可以在后面添加一个量词来匹配多个字符，例如`/[is]{2}/`可以匹配到Th<font color=red>is</font> is the first example  
通过在紧挨着字符组这个子匹配模式的后面添加一个用大括号包裹的具体数组，便可以规定字符组需要在文本中被连续匹配的次数，该形式由三种变体：  
`{m}` 只能出现m次
`{m, n}` 至少出现m次，最多出现n次
`{m, }` 至少出现m次
量词的一般形式写法使得大括号在正则表达式中有了特殊含义，成为了元字符，例如 `\w{3}` 匹配了 <font color=red>Thi</font>s is my first{3} example  
如果想匹配文本中的大括号，我们可以转义两个大括号中的任意一个，这样，正则表达式找不到对应的量词形式，便会将大括号作为普通字符去匹配，例如
`\w\{3}` 和 `\w{3\}`都会匹配 This is my fiir<font color=red>r{3}</font> example

1. 同范围表示法类似，对于某些常见的量词，正则表达式也提供了相应的简记法可以使用，例如 `/colou?rs?` 这里的问号表示前面的匹配出现了0次或1次，这个表达式可以匹配 color, colour, colors, colours  
量词简记法有下面几个：  
`*` 表示出现任意次，等同于`{0,}`
`+` 表示至少出现1次，等同于`{1,}`
`?` 表示出现0次或1次，等同于`{0,1}`

1. 一个特殊的元字符
点号可用于匹配除换行符以外的任意字符，例如`/.*/` 和 `/[\s\S]*` 的区别在于前者不包含换行符。

1. 贪婪和非贪婪
this is my first example 这句话由5个单词构成，如果我们要将两个空格之间的单词匹配出来，我们会用 `\s.*\s` 来匹配，可是我们发现，它匹配的是this<font style="background: #FF0000"> is my first </font>example  
这是因为在默认情况下，所有的量词均为贪婪量词，这意味着，它们会尽可能的进行匹配  
通过在原有量词的后面添加一个问号，我们可以把原来的贪婪量词变为懒惰量词，例如
`\s.*?\s` 就可以匹配 this<font style="background: #FF0000"> is </font>my first example  
顾名思义，懒惰量词会让被标记的子模式仅保持可能的最小匹配  

### 括号 parentheses  
1. 括号用于对子匹配模式进行分组(group)，以将它们进行整体控制  
例如，我们需要验证给定目标字符串是否为一个合法的文件名，首先，名称和相应的扩展名后缀都由字母，数字和下划线组成：  
`/\w+\.\w+/`  
名称部分不超过255个字符  
`/\w{1,255}\.\w+/`  
第一个字符不能为数字  
`/[a-zA-Z_]\w{0,254}\.\w+/`  
后缀可选  
`/[a-zA-Z_]\w{0,254}(\.\w+)?/`  
在最后一步我们就要借助括号的分组能力，将点号在内的整个后缀匹配模式作为一个分组进行单独控制，紧接着的问号控制这个分组出现的次数为0次或1次  

1. 括号的多选结构
如果要求后缀仅可为.php, .js和.cc中的一个，那么我们可以用一个为多选结构的特性  
括号内的子表达式可以被分割为多个分支，进行多选一匹配
`/[a-zA-Z_]\w{0,254}(\.php|\.js|\.cc)?/`  

1. 作用范围
我们用这个正则表达式去匹配以下几个文本
<font style="background: #FF0000">filename.php</font>  
<font style="background: #FF0000">filename.js</font>  
<font style="background: #FF0000">filename</font>  
<font style="background: #FF0000">filename</font>.java  
最后一个不是我们想要的，原因在于我们没有限定正则需要在目标文本上的作用范围，因此，它会优先寻找在目标文本中，可以匹配的某个子集。  
通过适当修改，我们可以限定正则的作用范围：  
`/^[a-zA-Z_]\w{0,254}(\.php|\.js|\.cc)?$/`  
如果要匹配括号字符，那么左右括号必须都要转义


1. 反向引用
思考一个问题，如何编写一个正则表达式来检查文本中是否有连续出现的相同字符  
`/\w\w/`表示相邻的两个字符，但无法确定它们之间的关系  
`/(aa|bb|cc|dd...)/` 将相同字符的可能全部列举出来，这个可以达到目的但是过于繁琐
`/(\w)\1/` 借助反向引用，可以轻松实现，反向引用，顾名思义，表示引用之前括号分组内，已经成功匹配的文本内容，这里 \1 就表示引用第1个分组已匹配的内容  
this is my first t<font style="background: #ff0000">ee</font>xt.  
注意，分组的编号是按照开括号的顺序来递增的，例如
`/(((\d)-(\d))-(\d))/`

1. 非捕获分组  
由于括号内的内容都会被正则表达式记录下来，以供后面反向引用，对于不需要捕获的分组，在括号内添加`?:`，可以把该分组标记为非捕获分组，该分组匹配的内容不会被保留， 例如  
`/^\d{7}(?:\d{3})/`匹配 <font style="background: #ff0000">0123456789</font> 其中 789 就不会被记录下来，无法反向引用

